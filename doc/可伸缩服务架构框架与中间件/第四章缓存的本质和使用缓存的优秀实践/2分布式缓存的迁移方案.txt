1、平滑迁移：
	1、双写：按照新规则和旧规则同时往新缓存和旧缓存中写数据。
	这里，我们按照旧的规则也就是对2取模来路由分片，同时按照新的规则，也就是关键字对4取模路由到新的4个分片上，来完成双写。
	这个步骤可以优化，因为在成倍扩容的场景下，我们不需要准备4个全新的分片，新规则中前两个分片的数据，其实是旧规则中两个分片数据的子集，并且规则一致，所以我们可以重用前
	两个分片，也就是说一共需要两个新的分片，用来处理关键字哈希取模后为2和3的情况，使用旧的缓存分片来处理关键字取模后为0和1的情况。
	
	2、迁移历史数据，把旧缓存集群中的历史数据读取出来，按照新的规则写到新的缓存集群中。
	这里我们需要迁移历史数据，在迁移过程中可能需要迁移工具，迁移后，还需要对迁移的数据进行验证，表明我们的数据迁移成功。
	在某些场景下，缓存数据并不是应用强依赖的，在缓存里获取不到数据，可以回到数据库获取，因此在这种情况下通过容量评估，数据库可以承受回源导致的压力增加，就可以避免旧数据迁
	移。在另一个场景下，缓存数据一般具有时效性，应用在双写期间不断向新集群写入数据，历史数据会逐渐过期，并从旧的集群中删除，在一定的时间流逝后，在新的集群自然就有了最新的
	数据。也就不需要迁移历史数据了。
	
	3、切读：把应用层所有的读操作路由到新的缓存集群上。
	这一步把应用中读取的操作的缓存数据源转换到新的缓存集群，这时应用的读写操作已经完全发生在新的缓存集群上了，这一步一般不需要上线，我们会在一开始上线双写时就实现开关操作，
	这里只需要将读的开关切换到新的集群即可。
	
	4、下线双写：把写入旧的集群的逻辑下线。
	这一步通常是在双写和切读后验证没有问题，并保证数据一致性的情况下，才把这部分代码下线，同时可以把旧的分片下线，如果是扩容的场景，并且重用了旧的分片1和分片2，则还可以清
	理分片1和分片2中的多余数据。